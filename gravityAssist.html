<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gravity Assist v2</title>
<style>
body { margin:0; overflow:hidden; background:black; font-family:sans-serif; }
canvas { display:block; }
#ui {
  position:absolute; top:10px; left:10px; color:white;
}
</style>
</head>
<body>
<div id="ui">Score: <span id="score">0</span> | Level: <span id="level">1</span></div>
<canvas id="c"></canvas>
<script>
const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d');
const scoreEl=document.getElementById('score');
const levelEl=document.getElementById('level');

let W,H;
function resize(){ W=canvas.width=window.innerWidth; H=canvas.height=window.innerHeight; }
window.addEventListener('resize',resize);
resize();

// Player
let player={x:100, y:H/2, vx:0, vy:0, color:'cyan', radius:12, score:0};

// Gravity field controlled by mouse
let mouse={x:player.x, y:player.y};
window.addEventListener('mousemove', e=>{ mouse.x=e.clientX; mouse.y=e.clientY; });

// Side-scrolling world
let scrollSpeed=2;
let level=1;

// Targets (points to collect)
let targets=[];
let numTargets=5;

// Obstacles (repulsors / enemies)
let obstacles=[];
let numObstacles=3;

function spawnTargets(){
    targets=[];
    for(let i=0;i<numTargets;i++){
        targets.push({
            x: W + Math.random()*W*2,
            y: Math.random()*H,
            radius:10+Math.random()*5,
            color:`hsl(${Math.random()*360},80%,60%)`
        });
    }
}

function spawnObstacles(){
    obstacles=[];
    for(let i=0;i<numObstacles;i++){
        obstacles.push({
            x: W + Math.random()*W*3,
            y: Math.random()*H,
            radius:20+Math.random()*10
        });
    }
}

spawnTargets();
spawnObstacles();

// Draw functions
function drawPlayer(){
    ctx.fillStyle=player.color;
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.radius,0,Math.PI*2);
    ctx.fill();
}

function drawTargets(){
    targets.forEach(t=>{
        ctx.fillStyle=t.color;
        ctx.beginPath();
        ctx.arc(t.x, t.y, t.radius,0,Math.PI*2);
        ctx.fill();
    });
}

function drawObstacles(){
    ctx.strokeStyle='rgba(255,0,0,0.6)';
    ctx.lineWidth=3;
    obstacles.forEach(o=>{
        ctx.beginPath();
        ctx.arc(o.x, o.y, o.radius,0,Math.PI*2);
        ctx.stroke();
    });
}

// Update
function updatePlayer(){
    let dx = mouse.x - player.x;
    let dy = mouse.y - player.y;
    player.vx += dx*0.01;
    player.vy += dy*0.01;
    player.vx *= 0.92;
    player.vy *= 0.92;
    player.x += player.vx;
    player.y += player.vy;

    if(player.y<0) player.y=0;
    if(player.y>H) player.y=H;
}

function updateWorld(){
    // Move targets and obstacles left
    targets.forEach(t=> t.x -= scrollSpeed);
    obstacles.forEach(o=> o.x -= scrollSpeed);

    // Recycle targets & obstacles
    targets.forEach(t=>{ if(t.x<-50){ t.x=W + Math.random()*W; t.y=Math.random()*H; t.color=`hsl(${Math.random()*360},80%,60%)`; }});
    obstacles.forEach(o=>{ if(o.x<-50){ o.x=W + Math.random()*W; o.y=Math.random()*H; }});
}

// Collision
function checkCollisions(){
    targets.forEach(t=>{
        let dx=player.x-t.x;
        let dy=player.y-t.y;
        let d=Math.sqrt(dx*dx+dy*dy);
        if(d<player.radius+t.radius){
            player.color=t.color;
            player.score++;
            scoreEl.innerText=player.score;
            // push target ahead to recycle
            t.x=W + Math.random()*W;
            t.y=Math.random()*H;
            t.color=`hsl(${Math.random()*360},80%,60%)`;
        }
    });

    obstacles.forEach(o=>{
        let dx=player.x-o.x;
        let dy=player.y-o.y;
        let d=Math.sqrt(dx*dx+dy*dy);
        if(d<player.radius+o.radius){
            // hit obstacle â†’ lose score, reset player slightly
            player.score = Math.max(0, player.score-2);
            scoreEl.innerText=player.score;
            player.x = 100;
            player.y = H/2;
        }
    });
}

// Level system
function checkLevel(){
    let newLevel = Math.floor(player.score/10)+1;
    if(newLevel>level){
        level=newLevel;
        scrollSpeed+=0.5;
        numTargets+=1;
        numObstacles+=1;
        spawnTargets();
        spawnObstacles();
        levelEl.innerText = level;
    }
}

// Trail
let trail = [];
function drawTrail(){
    trail.push({x:player.x, y:player.y, color:player.color});
    if(trail.length>100) trail.shift();
    trail.forEach((p,i)=>{
        ctx.fillStyle=p.color;
        ctx.globalAlpha = i/trail.length*0.6;
        ctx.beginPath();
        ctx.arc(p.x,p.y,5,0,Math.PI*2);
        ctx.fill();
    });
    ctx.globalAlpha=1;
}

// Animate
function animate(){
    ctx.fillStyle='rgba(0,0,0,0.15)';
    ctx.fillRect(0,0,W,H);

    updatePlayer();
    updateWorld();
    checkCollisions();
    checkLevel();

    drawTrail();
    drawTargets();
    drawObstacles();
    drawPlayer();

    requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
